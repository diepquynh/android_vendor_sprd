#include <Tfa98xx.h>
#include <assert.h>
#include <string.h>
#ifdef WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/stat.h>
#include <NXP_I2C.h>
#ifndef WIN32
// need PIN access
#include <inttypes.h>
#include <lxScribo.h>
#endif

#include "nxpTfa98xx.h"
#include "tfa98xxRuntime.h"
#include "tfa98xxCalibration.h"
#include "tfa98xxLiveData.h"

#ifndef WIN32

#define Sleep(ms) usleep((ms)*1000)
#define _fileno fileno
#define _GNU_SOURCE   /* to avoid link issues with sscanf on NxDI? */
#endif

#define I2C_ADDRESS  0x68
#define SAMPLE_RATE 48000

#ifdef WIN32
// cwd = dir where vcxproj is
#define LOCATION_FILES "../../../../settings/"
#else
// cwd = linux dir
#define LOCATION_FILES "../../settings/"
#endif


/* for DUMBO speaker file, containing tCoef */
#define SPEAKER_FILENAME "KS_13X18_DUMBO.speaker"
#define PRESET_FILENAME "Example_0_0.KS_13X18_DUMBO.preset"
#define CONFIG_FILENAME "Setup.config"
#define EQ_FILENAME "Example_0_0.KS_13X18_DUMBO.eq"
/* the SELTEC speaker file, containing tCoef */
//#define SPEAKER_FILENAME "TFA9890N1C3/KS_13X18_DUMBO.speaker"
//#define PRESET_FILENAME "TFA9890N1C3/Example_0_0.KS_13X18_DUMBO.preset"
//#define CONFIG_FILENAME "TFA9890N1C3/TFA9890_N1B12_N1C3_v1.config"
//#define EQ_FILENAME "TFA9890N1C3/Example_0_0.KS_13X18_DUMBO.eq"

#if ( defined( TFA9890 ) )
#define PATCH_FILENAME "TFA9890_N1C3_2_1_1.patch"
// nor B12 #define PATCH_FILENAME "TFA9890_N1B12_3_2_3.patch"
#endif
#if ( defined( TFA9887B ) || defined( TFA98XX_FULL ))
#define DRC_FILENAME "DRCoff.drc"
#endif

#define SPEAKERPARAMETER_LENGTH 423
typedef unsigned char SpeakerParameters_t[SPEAKERPARAMETER_LENGTH];

#define CONFIG_LENGTH 165
typedef unsigned char ConfigParameters_t[CONFIG_LENGTH];

#define PRESET_LENGTH    87
typedef unsigned char PresetParameters_t[PRESET_LENGTH];

int cli_verbose=0;	/* verbose flag */
#define TFA_I2CSLAVEBASE		(0x34)              // tfa device slave address of 1st (=left) device
extern regdef_t regdefs[];
extern unsigned char  tfa98xxI2cSlave; // global for i2c access
//unsigned char  tfa98xxI2cSlave=TFA_I2CSLAVEBASE; // global for i2c access
int NXP_I2C_verbose=0;


/* global parameter cache */
extern nxpTfa98xxParameters_t tfaParams;


/* *INDENT-OFF* */
regdef_t regdefs[] = {
        { 0x00, 0x081d, 0xfeff, "statusreg"}, //ignore MTP busy bit
        { 0x01, 0x0, 0x0, "batteryvoltage"},
        { 0x02, 0x0, 0x0, "temperature"},
        { 0x03, 0x0012, 0xffff, "revisionnumber"},
        { 0x04, 0x888b, 0xffff, "i2sreg"},
        { 0x05, 0x13aa, 0xffff, "bat_prot"},
        { 0x06, 0x001f, 0xffff, "audio_ctr"},
        { 0x07, 0x0fe6, 0xffff, "dcdcboost"},
        { 0x08, 0x0800, 0x3fff, "spkr_calibration"}, //NOTE: this is a software fix to 0xcoo
        { 0x09, 0x041d, 0xffff, "sys_ctrl"},
        { 0x0a, 0x3ec3, 0x7fff, "i2s_sel_reg"},
        { 0x40, 0x0, 0x00ff, "hide_unhide_key"},
        { 0x41, 0x0, 0x0, "pwm_control"},
        { 0x46, 0x0, 0x0, "currentsense1"},
        { 0x47, 0x0, 0x0, "currentsense2"},
        { 0x48, 0x0, 0x0, "currentsense3"},
        { 0x49, 0x0, 0x0, "currentsense4"},
        { 0x4c, 0x0, 0xffff, "abisttest"},
        { 0x62, 0x0, 0, "mtp_copy"},
        { 0x70, 0x0, 0xffff, "cf_controls"},
        { 0x71, 0x0, 0, "cf_mad"},
        { 0x72, 0x0, 0, "cf_mem"},
        { 0x73, 0x00ff, 0xffff, "cf_status"},
        { 0x80, 0x0, 0, "mtp"},
        { 0x83, 0x0, 0, "mtp_re0"},
        { 0xff, 0,0, NULL}
};
/* *INDENT-ON* */

/* load a speaker model from a file, as generated by the GUI, or saved from a previous execution */
static void setSpeaker(int handle_cnt, Tfa98xx_handle_t handles[], const char* fileName)
{
	Tfa98xx_Error_t err;
	int ret;
	FILE* f;
    SpeakerParameters_t speakerBytes;

	printf("using speaker %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fread(speakerBytes, 1, sizeof(SpeakerParameters_t), f);
	assert(ret == sizeof(SpeakerParameters_t));
	
    ret = tfa98xxSetParamsMultiple(tfa_speaker_params, speakerBytes, sizeof(SpeakerParameters_t), handles, handle_cnt);
	assert(ret == sizeof(SpeakerParameters_t));
    
    //err = Tfa98xx_DspWriteSpeakerParametersMultiple(handle_cnt, handles, sizeof(SpeakerParameters_t), speakerBytes);
	//assert(err == Tfa98xx_Error_Ok);
	
    fclose(f);
}

/* load a config from a file, as generated by the GUI, can be done at runtime */
static void setConfig(int handle_cnt, Tfa98xx_handle_t handles[], const char* fileName)
{
	Tfa98xx_Error_t err;
	ConfigParameters_t config;
	int ret;
	FILE* f;

	printf("using config %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fread(config, 1, sizeof(config), f);
	assert(ret == CONFIG_LENGTH);

    ret = tfa98xxSetParamsMultiple(tfa_config_params, config, sizeof(ConfigParameters_t), handles, handle_cnt);
	assert(ret == sizeof(ConfigParameters_t));
    // old
	//err = Tfa98xx_DspWriteConfigMultiple(handle_cnt, handles, sizeof(ConfigParameters_t), config);
	//assert(err == Tfa98xx_Error_Ok);
	fclose(f);
}

/* load a preset from a file, as generated by the GUI, can be done at runtime */
static void setPreset(int handle_cnt, Tfa98xx_handle_t handles[], const char* fileName)
{
	int ret;
	int presetSize;
	unsigned char* buffer;
	FILE* f;
	struct stat st;
	Tfa98xx_Error_t err;
	
	printf("using preset %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fstat(_fileno(f), &st);
	assert(ret == 0);
	presetSize = st.st_size;
	assert(presetSize == PRESET_LENGTH);
	buffer = (unsigned char*)malloc(presetSize);
	assert(buffer != NULL);
	ret = fread(buffer, 1, presetSize, f);
	assert(ret == presetSize);
	
    ret = tfa98xxSetParamsMultiple(tfa_preset_params, buffer, PRESET_LENGTH, handles, handle_cnt);
	assert(ret == PRESET_LENGTH);
    //err = Tfa98xx_DspWritePresetMultiple(handle_cnt, handles, PRESET_LENGTH, buffer);
	//assert(err == Tfa98xx_Error_Ok);
	
    fclose(f);
	free(buffer);
}

/* load a set of EQ settings from a file, as generated by the GUI, can be done at runtime */
static void setEQ(int handle_cnt, Tfa98xx_handle_t handles[], const char* fileName)
{
	int ret;
	int eqSize;
	FILE* f;
	Tfa98xx_Error_t err;
	int ind; /* biquad index */
	float b0, b1, b2, a1, a2; /* the coefficients */
	int line = 1;
	unsigned char* buffer;
	struct stat st;

	printf("using EQ %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fstat(_fileno(f), &st);
	assert(ret == 0);
	eqSize = st.st_size;
	buffer = (unsigned char*)malloc(eqSize);
	assert(buffer != NULL);
	ret = fread(buffer, 1, eqSize, f);
	assert(ret == eqSize);
	
    ret = tfa98xxSetParamsMultiple(tfa_equalizer_params, buffer, eqSize, handles, handle_cnt);
	assert(ret == eqSize);
    //old;
	
    fclose(f);
	free(buffer);

    /**
	f=fopen(fileName, "rb");
	assert(f!=NULL);

	while (!feof(f))
	{
		if (NULL == fgets(buffer, sizeof(buffer)-1, f) )
		{
			break;
		}

		ret = sscanf(buffer, "%d %f %f %f %f %f", &ind, &b0, &b1, &b2, &a1, &a2);
		if (ret == 6)
		{
			if ((b0 != 1) || (b1 != 0) || (b2 != 0) || (a1 != 0) || (a2 != 0)) {
				err = Tfa98xx_DspBiquad_SetCoeffMultiple(handle_cnt, handles, ind, b0, b1, b2, a1, a2);
				assert(err == Tfa98xx_Error_Ok);
				printf("Loaded biquad %d\n", ind);
      } else {
        err = Tfa98xx_DspBiquad_DisableMultiple(handle_cnt, handles, ind);
				assert(err == Tfa98xx_Error_Ok);
				printf("Disabled biquad %d\n", ind);
			}
		}
		else {
			printf("error parsing file, line %d\n", line);
			//break;
		}
		line++;
	}
	fclose(f);
    **/
}

/* load a DSP ROM code patch from file */
static void dspPatch(Tfa98xx_handle_t handle, const char* fileName)
{
	int ret;
	int fileSize;
	unsigned char* buffer;
	FILE* f;
	struct stat st;
	Tfa98xx_Error_t err;

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fstat(_fileno(f), &st);
	assert(ret == 0);
	fileSize = st.st_size;
	buffer = (unsigned char*)malloc(fileSize);
	assert(buffer != NULL);
	ret = fread(buffer, 1, fileSize, f);
	assert(ret == fileSize);

    ret = tfa98xxSetParams(tfa_patch_params, buffer, fileSize, handle);
	assert(ret == fileSize);
	
    fclose(f);
	free(buffer);
}

static char* stateFlagsStr(int stateFlags)
{
	static char flags[10];
	
	flags[0] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_Activity)) ? 'A':'a';
	flags[1] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_S_Ctrl)) ? 'S':'s';
	flags[2] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_Muted)) ? 'M':'m';
	flags[3] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_X_Ctrl)) ? 'X':'x';
	flags[4] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_T_Ctrl)) ? 'T':'t';
	flags[5] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_NewModel)) ? 'L':'l';
	flags[6] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_VolumeRdy)) ? 'V':'v';
	flags[7] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_Damaged)) ? 'D':'d';
	flags[8] = (stateFlags & (0x1<<Tfa98xx_SpeakerBoost_SignalClipping)) ? 'C':'c';

	flags[9] = 0;
	return flags;
}

static void dumpStateInfo( nxpTfa98xx_LiveData_t* pState)
{
    nxpTfa98xx_LiveData_t record;
  printf("state: flags %s, agcGain %2.1f\tlimGain %2.1f\tsMax %2.1f\tT %d\tX1 %2.1f\tX2 %2.1f\tRe %2.2f\n", 
      stateFlagsStr(pState->statusFlags),
				pState->agcGain, 
                pState->limitGain, 
                pState->limitClip, 
                pState->speakerTemp, 
                pState->boostExcursion, 
                pState->manualExcursion,
                pState->speakerResistance);
}

int main(/* int argc, char* argv[] */)
{
	Tfa98xx_Error_t err;
    nxpTfa98xx_Error_t errRet;
	Tfa98xx_handle_t handles[3];
    Tfa98xx_handle_t devicehandles[] = {0, 1}; //stereo device
	//Tfa98xx_handle_t *devicehandles;
	unsigned char h;
	Tfa98xx_StateInfo_t stateInfo;
	float re25;
	int i;
    nxpTfa98xx_LiveData_t record;

    errRet = tfaRunStartupAll(handles);

    // load the patch
    for (h=0; h<2; h++)
	{
		/* hack: force recalibration when starting up without needing to remove Vdd */
		dspPatch(handles[h], LOCATION_FILES "coldboot.patch");

#ifdef 	PATCH_FILENAME
    /* patch the ROM code */
    dspPatch(handles[h], LOCATION_FILES PATCH_FILENAME);
#endif
	}

	/* load predefined, or fullmodel from file */
	setSpeaker(2, handles, LOCATION_FILES SPEAKER_FILENAME);
	//setSpeaker(2, handles, "saved.speaker", loadedSpeaker);
	
	/* load the settings */
	setConfig(2, handles, LOCATION_FILES CONFIG_FILENAME);
	/* load a preset */
	setPreset(2, handles, LOCATION_FILES PRESET_FILENAME);
	/* set the equalizer to Rock mode */
	setEQ(2, handles, LOCATION_FILES EQ_FILENAME);

    tfa98xxSelectStereo(handles);

	/* all settings loaded, signal the DSP to start calibration */
    tfa98xxCalSetConfigured(handles);

	for (h=0; h<2; h++)
	{
		re25 = tfa98xxCalGetTcoef(handles[h]);
		while (fabs(re25) < 0.1)
		{
		    re25 = tfa98xxCalGetTcoef(handles[h]);
		}
		printf("Calibration value for device %d is %2.2f ohm\n", h, re25);
	}

	for(i=0;i<50;i++)    // counter for state_info
	{
		for (h=0; h<2; h++)
		{
            errRet = nxpTfa98xxGetLiveData( handles, h, &record);
			assert(errRet == nxpTfa98xx_Error_Ok);
			dumpStateInfo(&record);
		}
		Sleep(1000);
	}

    tfaRunShutDownAll(handles);

	return 0;
}
